package edu.achriste.processing;

/**
 * Represents a disk structuring element.
 *
 * @author Anthony Christe
 */
public class DiskSE {
  /**
   * Matrix of bytes that represent a disk structuring element.
   * Values of 0 represent background and values of 1 represent foreground.
   */
  private byte[][] disk;

  /**
   * Radius of disk SE.
   */
  private int radius;

  /**
   * Constructs a disk structuring element with the given radius.
   * @param radius The radius.
   */
  public DiskSE(int radius) {
    // This ensures that the radius is calculated from the correct center point.
    this.radius = radius - 1;
    int diameter = this.radius * 2;

    // Pad 1 or 2 rows/cols to fit circle generated by midpoint circle algorithm
    if (diameter % 2 == 0) {
      disk = new byte[diameter + 1][diameter + 1];
    } else {
      disk = new byte[diameter + 2][diameter + 2];
    }

    midpointCircle();
    fillCircle();
  }

  /**
   * Algorithm adapted from example at https://en.wikipedia.org/wiki/Midpoint_circle_algorithm.
   * Creates an open circle where the circle itself is represented by foreground pixels.
   */
  private void midpointCircle() {
    int x = radius;
    int y = 0;
    int midpoint = disk.length / 2;
    int radiusError = 1 - x;

    while (x >= y) {
      disk[x + midpoint][y + midpoint] = 1;
      disk[y + midpoint][x + midpoint] = 1;
      disk[-x + midpoint][y + midpoint] = 1;
      disk[-y + midpoint][x + midpoint] = 1;
      disk[-x + midpoint][-y + midpoint] = 1;
      disk[-y + midpoint][-x + midpoint] = 1;
      disk[x + midpoint][-y + midpoint] = 1;
      disk[y + midpoint][-x + midpoint] = 1;

      y++;

      if (radiusError < 0) {
        radiusError += 2 * y + 1;
      } else {
        x--;
      }
    }
  }

  /**
   * Fills the circle created from the midpoint circle algorithm with foreground pixels.
   */
  private void fillCircle() {
    boolean inCircle = false;

    for (int r = 1; r < disk.length - 1; r++) {
      for (int c = 0; c < disk[r].length; c++) {
        // Entering circle. Found a foreground pixel, but not yet in the circle.
        if (disk[r][c] == 1 && !inCircle) {
          inCircle = true;
          continue;
        }
        // Exiting circle. Found the other side.
        if (disk[r][c] == 1 && inCircle) {
          inCircle = false;
          continue;
        }
        // In circle, set background to foreground
        if (disk[r][c] == 0 && inCircle) {
          disk[r][c] = 1;
        }
      }
    }
  }

  /**
   * Returns the value at the specified row and column.
   * @param r Row.
   * @param c Column.
   * @return The value of the disk SE at the row and column.
   */
  public byte get(int r, int c) {
    return disk[r][c];
  }

  /**
   * Returns the height of the disk SE.
   * @return
   */
  public int getHeight() {
    return disk[0].length;
  }

  /**
   * Returns the width of the disk SE.
   * @return
   */
  public int getWidth() {
    return disk.length;
  }
}
